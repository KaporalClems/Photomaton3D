<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photomaton Studio Pro - √âditeur 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        .preview-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16/9;
            background: #000;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            touch-action: none;
        }
        #videoFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .mirror {
            transform: scaleX(-1);
        }
        #threeCanvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto; /* Permettre les interactions sur le canvas 3D */
            z-index: 5;
        }
        .draggable-element {
            position: absolute;
            cursor: move;
            user-select: none;
            z-index: 10;
            border: 2px dashed transparent;
        }
        .draggable-element.active {
            border-color: #3b82f6;
        }
        #templateWrapper { top: 10%; left: 10%; width: 30%; }
        
        .resize-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #3b82f6;
            border: 3px solid white;
            border-radius: 50%;
            bottom: -12px;
            right: -12px;
            cursor: nwse-resize;
            display: none;
        }
        .active .resize-handle { display: block; }

        .flash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 100;
        }
        @keyframes flash-anim { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }
        .animate-flash { animation: flash-anim 0.4s ease-out; }
        
        #errorOverlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.8);
            display: none; flex-direction: column; align-items: center;
            justify-content: center; padding: 20px; text-align: center; z-index: 50;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen flex flex-col items-center p-2 sm:p-4 font-sans">

    <header class="text-center mb-4 sm:mb-6">
        <h1 class="text-3xl sm:text-4xl font-black tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-yellow-400 via-orange-500 to-red-600">
            STUDIO 3D MOBILE
        </h1>
        <p class="text-xs sm:text-sm text-slate-400">Cr√©ez votre design interactif en temps r√©el.</p>
    </header>

    <main class="w-full max-w-6xl grid grid-cols-1 xl:grid-cols-4 gap-4 sm:gap-6">
        
        <div class="xl:col-span-3 flex flex-col items-center">
            <div class="preview-container border border-slate-800" id="editorZone">
                <video id="videoFeed" autoplay playsinline muted class="mirror"></video>
                
                <!-- Zone Three.js -->
                <div id="threeCanvasContainer"></div>

                <div id="errorOverlay">
                    <p class="text-white font-bold mb-2 text-sm sm:text-base">Erreur Cam√©ra</p>
                    <button onclick="initCam()" class="bg-slate-700 px-4 py-2 rounded-lg text-xs">R√©essayer</button>
                </div>

                <!-- Bouton Switch Cam√©ra -->
                <button id="btnSwitchCam" class="absolute top-4 right-4 z-20 bg-black/50 p-3 rounded-full border border-white/20 hover:bg-black/80 transition-all">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                </button>

                <!-- Cadre image manipulable -->
                <div id="templateWrapper" class="draggable-element hidden">
                    <img id="templateOverlay" src="" alt="" class="w-full pointer-events-none">
                    <div class="resize-handle" id="resizeHandle"></div>
                </div>

                <div id="flashOverlay" class="flash"></div>
                <div id="countdown" class="absolute inset-0 flex items-center justify-center text-8xl sm:text-9xl font-black text-white drop-shadow-2xl hidden z-[100]"></div>
            </div>

            <div class="mt-4 sm:mt-6 w-full flex flex-col sm:row gap-4 items-center justify-center">
                <button id="btnCapture" class="w-full sm:w-auto bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white px-8 sm:px-12 py-3 sm:py-4 rounded-2xl font-bold text-lg sm:text-xl shadow-xl transition-all active:scale-95 flex items-center justify-center gap-3">
                    üì∏ PRENDRE LA PHOTO
                </button>
            </div>
        </div>

        <!-- Panneau lat√©ral -->
        <div class="bg-slate-900 p-4 sm:p-6 rounded-3xl border border-slate-800 shadow-2xl space-y-6 overflow-y-auto max-h-[80vh] xl:max-h-none">
            
            <!-- EXPORT -->
            <div>
                <h2 class="text-base sm:text-lg font-bold mb-3 flex items-center gap-2">
                    <span class="w-2 h-6 bg-yellow-500 rounded-full"></span>
                    Projet
                </h2>
                <input type="text" id="fileNameInput" placeholder="Nom du fichier" class="w-full bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm focus:outline-none focus:border-yellow-500">
            </div>

            <!-- PERSONNALISATION TEXTE 3D -->
            <div>
                <h2 class="text-base sm:text-lg font-bold mb-3 flex items-center gap-2 text-blue-400">
                    <span class="w-2 h-6 bg-blue-500 rounded-full"></span>
                    Texte 3D
                </h2>
                <div class="space-y-3">
                    <label class="flex items-center gap-2 text-xs sm:text-sm cursor-pointer bg-slate-800 p-3 rounded-xl">
                        <input type="checkbox" id="toggle3D" checked class="w-4 h-4">
                        Afficher le texte
                    </label>
                    
                    <div class="space-y-1">
                        <span class="text-[10px] text-slate-500 font-bold uppercase">Message</span>
                        <textarea id="text3DInput" rows="2" class="w-full bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm focus:outline-none focus:border-blue-500" placeholder="JOYEUX ANNIVERSAIRE"></textarea>
                    </div>

                    <div class="space-y-1">
                        <span class="text-[10px] text-slate-500 font-bold uppercase">Police</span>
                        <select id="fontSelect" class="w-full bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm focus:outline-none focus:border-blue-500">
                            <option value="helvetiker_bold">Moderne (Helvetica)</option>
                            <option value="gentilis_bold">√âl√©gante (Gentilis)</option>
                            <option value="optimer_bold">Technique (Optimer)</option>
                        </select>
                    </div>

                    <p class="text-[10px] text-slate-400 italic">Astuce: Cliquez/Glissez sur le texte 3D pour le d√©placer.</p>
                </div>
            </div>

            <!-- CADRE PNG -->
            <div>
                <h2 class="text-base sm:text-lg font-bold mb-3 flex items-center gap-2 text-orange-400">
                    <span class="w-2 h-6 bg-orange-500 rounded-full"></span>
                    Cadre / Logo
                </h2>
                <label class="block group cursor-pointer">
                    <div class="border-2 border-dashed border-slate-700 hover:border-orange-500 rounded-2xl p-4 text-center transition-all bg-slate-950/50">
                        <span class="text-xs font-medium text-slate-400">Ajouter Image (PNG)</span>
                        <input type="file" id="uploadTemplate" accept="image/*" class="hidden">
                    </div>
                </label>
            </div>

            <!-- CACHE -->
            <div class="pt-4 border-t border-slate-800">
                <button id="btnClearCache" class="text-[10px] text-slate-500 hover:text-red-400 transition-colors uppercase font-bold">
                    R√©initialiser le studio
                </button>
            </div>

            <div id="resultArea" class="pt-4 border-t border-slate-800 hidden">
                <h2 class="text-base sm:text-lg font-bold mb-3 text-yellow-400">Derni√®re Capture</h2>
                <div id="gallery"></div>
            </div>
        </div>
    </main>

    <canvas id="canvasProcess" class="hidden"></canvas>

    <script>
        const video = document.getElementById('videoFeed');
        const templateWrapper = document.getElementById('templateWrapper');
        const templateOverlay = document.getElementById('templateOverlay');
        const btnCapture = document.getElementById('btnCapture');
        const btnSwitchCam = document.getElementById('btnSwitchCam');
        const uploadTemplate = document.getElementById('uploadTemplate');
        const canvas = document.getElementById('canvasProcess');
        const flashOverlay = document.getElementById('flashOverlay');
        const countdownEl = document.getElementById('countdown');
        const gallery = document.getElementById('gallery');
        const editorZone = document.getElementById('editorZone');
        const fileNameInput = document.getElementById('fileNameInput');
        const toggle3D = document.getElementById('toggle3D');
        const text3DInput = document.getElementById('text3DInput');
        const fontSelect = document.getElementById('fontSelect');
        const btnClearCache = document.getElementById('btnClearCache');
        const container3D = document.getElementById('threeCanvasContainer');

        let scene, camera, renderer, textMesh;
        let isDraggingText = false, isDraggingImg = false, isResizingImg = false;
        let startX, startY, startW, startLeft, startTop;
        let currentFacingMode = 'user';

        // Raycaster pour d√©tecter le texte 3D
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- CACHE ---
        const CACHE_KEYS = {
            FILENAME: 'photomaton_v2_filename',
            TOGGLE3D: 'photomaton_v2_3d_on',
            TEXTCONTENT: 'photomaton_v2_text',
            FONTSTYLE: 'photomaton_v2_font',
            TEXTPOS: 'photomaton_v2_textpos',
            TEMPLATE_IMAGE: 'photomaton_v2_img_src',
            TEMPLATE_POS: 'photomaton_v2_img_pos'
        };

        function saveSettings() {
            localStorage.setItem(CACHE_KEYS.FILENAME, fileNameInput.value);
            localStorage.setItem(CACHE_KEYS.TOGGLE3D, toggle3D.checked);
            localStorage.setItem(CACHE_KEYS.TEXTCONTENT, text3DInput.value);
            localStorage.setItem(CACHE_KEYS.FONTSTYLE, fontSelect.value);
            
            if (textMesh) {
                localStorage.setItem(CACHE_KEYS.TEXTPOS, JSON.stringify({
                    x: textMesh.position.x,
                    y: textMesh.position.y,
                    scale: textMesh.scale.x
                }));
            }

            if (!templateWrapper.classList.contains('hidden')) {
                localStorage.setItem(CACHE_KEYS.TEMPLATE_POS, JSON.stringify({
                    top: templateWrapper.style.top,
                    left: templateWrapper.style.left,
                    width: templateWrapper.style.width
                }));
            }
        }

        function loadSettings() {
            fileNameInput.value = localStorage.getItem(CACHE_KEYS.FILENAME) || "";
            toggle3D.checked = localStorage.getItem(CACHE_KEYS.TOGGLE3D) !== 'false';
            text3DInput.value = localStorage.getItem(CACHE_KEYS.TEXTCONTENT) || "JOYEUX\nANNIVERSAIRE";
            fontSelect.value = localStorage.getItem(CACHE_KEYS.FONTSTYLE) || "helvetiker_bold";

            const cachedImg = localStorage.getItem(CACHE_KEYS.TEMPLATE_IMAGE);
            if (cachedImg) {
                templateOverlay.src = cachedImg;
                templateWrapper.classList.remove('hidden');
                const pos = JSON.parse(localStorage.getItem(CACHE_KEYS.TEMPLATE_POS));
                if (pos) {
                    templateWrapper.style.top = pos.top;
                    templateWrapper.style.left = pos.left;
                    templateWrapper.style.width = pos.width;
                }
            }
        }

        // --- THREE.JS ---
        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, editorZone.clientWidth / editorZone.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(editorZone.clientWidth, editorZone.clientHeight);
            container3D.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);
            
            updateText3D();
            camera.position.z = 5;
            animate3D();
        }

        function updateText3D() {
            if (!toggle3D.checked) {
                if (textMesh) textMesh.visible = false;
                return;
            }

            const loader = new THREE.FontLoader();
            const fontName = fontSelect.value;
            loader.load(`https://threejs.org/examples/fonts/${fontName}.typeface.json`, function (font) {
                if (textMesh) scene.remove(textMesh);
                
                const textGeo = new THREE.TextGeometry(text3DInput.value, {
                    font: font,
                    size: 0.4,
                    height: 0.1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.01
                });
                textGeo.center();
                
                const material = new THREE.MeshPhongMaterial({ color: 0xffcc00, shininess: 100 });
                textMesh = new THREE.Mesh(textGeo, material);
                
                // Charger la position du cache
                const cachedPos = JSON.parse(localStorage.getItem(CACHE_KEYS.TEXTPOS));
                if (cachedPos) {
                    textMesh.position.set(cachedPos.x, cachedPos.y, 0);
                    textMesh.scale.setScalar(cachedPos.scale);
                } else {
                    textMesh.position.y = 1;
                }
                
                scene.add(textMesh);
            });
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (textMesh && !isDraggingText) {
                textMesh.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
            }
            renderer.render(scene, camera);
        }

        // --- INTERACTIONS CANVAS (Titre 3D) ---
        container3D.addEventListener('mousedown', onPointerDown, false);
        container3D.addEventListener('touchstart', onPointerDown, {passive: false});

        function onPointerDown(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                isDraggingText = true;
                startX = clientX;
                startY = clientY;
            }
        }

        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('touchmove', onPointerMove, {passive: false});

        function onPointerMove(e) {
            if (!isDraggingText) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const dx = (clientX - startX) * 0.01;
            const dy = (clientY - startY) * 0.01;

            if (textMesh) {
                textMesh.position.x += dx;
                textMesh.position.y -= dy;
            }

            startX = clientX;
            startY = clientY;
            saveSettings();
        }

        window.addEventListener('mouseup', () => isDraggingText = false);
        window.addEventListener('touchend', () => isDraggingText = false);

        // --- INTERACTIONS IMAGE (Cadre) ---
        templateWrapper.addEventListener('mousedown', (e) => handleImgStart(e));
        templateWrapper.addEventListener('touchstart', (e) => handleImgStart(e));

        function handleImgStart(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            if (e.target.id === 'resizeHandle') isResizingImg = true;
            else isDraggingImg = true;

            startX = clientX; startY = clientY;
            startLeft = templateWrapper.offsetLeft; startTop = templateWrapper.offsetTop;
            startW = templateWrapper.offsetWidth;
            templateWrapper.classList.add('active');
        }

        window.addEventListener('mousemove', (e) => {
            if (!isDraggingImg && !isResizingImg) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            if (isDraggingImg) {
                templateWrapper.style.left = (startLeft + (clientX - startX)) + 'px';
                templateWrapper.style.top = (startTop + (clientY - startY)) + 'px';
            }
            if (isResizingImg) {
                templateWrapper.style.width = Math.max(50, startW + (clientX - startX)) + 'px';
            }
        });

        window.addEventListener('mouseup', () => { 
            isDraggingImg = false; isResizingImg = false; 
            templateWrapper.classList.remove('active');
            saveSettings();
        });

        // --- CAMERA & UI ---
        async function initCam() {
            if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
            video.classList.toggle('mirror', currentFacingMode === 'user');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: currentFacingMode, width: 1280, height: 720 } 
                });
                video.srcObject = stream;
            } catch (e) { document.getElementById('errorOverlay').style.display = 'flex'; }
        }

        btnSwitchCam.onclick = () => { currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user'; initCam(); };
        
        text3DInput.oninput = () => { updateText3D(); saveSettings(); };
        fontSelect.onchange = () => { updateText3D(); saveSettings(); };
        toggle3D.onchange = () => { updateText3D(); saveSettings(); };
        fileNameInput.oninput = saveSettings;

        uploadTemplate.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const r = new FileReader();
                r.onload = (f) => {
                    templateOverlay.src = f.target.result;
                    templateWrapper.classList.remove('hidden');
                    try { localStorage.setItem(CACHE_KEYS.TEMPLATE_IMAGE, f.target.result); } catch(e){}
                    saveSettings();
                };
                r.readAsDataURL(file);
            }
        };

        // --- CAPTURE ---
        btnCapture.onclick = () => {
            let c = 3;
            countdownEl.classList.remove('hidden');
            const t = setInterval(() => {
                countdownEl.textContent = c;
                if (c-- <= 0) {
                    clearInterval(t);
                    countdownEl.classList.add('hidden');
                    doCapture();
                }
            }, 800);
        };

        function doCapture() {
            flashOverlay.classList.add('animate-flash');
            setTimeout(() => flashOverlay.classList.remove('animate-flash'), 400);

            const vW = video.videoWidth, vH = video.videoHeight;
            canvas.width = vW; canvas.height = vH;
            const ctx = canvas.getContext('2d');

            ctx.save();
            if (currentFacingMode === 'user') { ctx.translate(vW, 0); ctx.scale(-1, 1); }
            ctx.drawImage(video, 0, 0, vW, vH);
            ctx.restore();

            if (toggle3D.checked && renderer) {
                renderer.render(scene, camera);
                ctx.drawImage(renderer.domElement, 0, 0, vW, vH);
            }

            if (!templateWrapper.classList.contains('hidden')) {
                const rect = editorZone.getBoundingClientRect();
                const wrap = templateWrapper.getBoundingClientRect();
                const sx = vW / rect.width, sy = vH / rect.height;
                ctx.drawImage(templateOverlay, (wrap.left-rect.left)*sx, (wrap.top-rect.top)*sy, wrap.width*sx, wrap.height*sy);
            }

            const name = (fileNameInput.value || 'photo') + '_' + Date.now() + '.png';
            const url = canvas.toDataURL('image/png');
            document.getElementById('resultArea').classList.remove('hidden');
            gallery.innerHTML = `<img src="${url}" class="rounded-xl border border-slate-700 shadow-lg"><a href="${url}" download="${name}" class="mt-2 block bg-blue-600 text-center py-2 rounded-lg text-sm font-bold">TELECHARGER</a>`;
        }

        btnClearCache.onclick = () => { if(confirm("Vider le cache ?")) { localStorage.clear(); location.reload(); } };

        window.onload = () => { loadSettings(); initCam(); init3D(); };
        window.onresize = () => {
            const w = editorZone.clientWidth, h = editorZone.clientHeight;
            renderer.setSize(w, h); camera.aspect = w/h; camera.updateProjectionMatrix();
        };
    </script>
</body>
</html>
